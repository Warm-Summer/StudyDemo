# JS语言概述

## JS语言简史

1. JS语言的起源

网景（Netscape Communication Corperation），1994年，推出第一款商用浏览器，网景浏览器（Netscape Navigator）

1995年，网景公司决定在浏览器中加入一门语言，可以作交互效果，提高用户体验。

最终决定独立开发一门新的语言，聘请Brendan Eich，10天后，新的语言诞生

LiveScript -> JavaScript (JS)

**JS语言之父：Brendan Eich**

2. 第一次浏览器大战

网景公司打算在浏览器中加入网络操作系统，影响到微软的利益，引起了微软的注意

1995年，微软发布IE浏览器。

JS语言推出之后，网景获得极大的竞争优势。

微软对JS语言反编译，借鉴JS语言，退出了JScript、VBScript

第一次浏览器大战是标准之争

1997，网景公司将javascript1.1版本提交给ECMA（欧洲计算机制造协会）

IE3发布，并绑定windows操作系统。

1998年，网景公司，被收购。

**ECMA收录了JavaScript，并提交给ISO，经过修改，成为了第一个JS的标准版本，成为ECMAScript，简称ES**

3. 第二次浏览器大战

IE4、IE5、IE6（windows xp）

微软决定解散浏览器团队。

Brendan Eich，带领团队成立Mozilla基金会，并决定，将网景浏览器开源。

长时间内，世界的技术爱好者，对网景浏览器，进行维护和打补丁

2002，Mozilla推出firefox浏览器。

2008，谷歌推出chrome浏览器，苹果推出safari，ASA公司推出opera

chrome浏览器搭载JS执行引擎V8（V8引擎，可以将JS代码直接转换为字节码，理论上，JS代码的执行速度已经接近汇编语言）

于是，JS具备了编写大型应用程序的能力，甚至服务器应用

> Ryan Dahl 准备写一个服务器端的框架，直接利用V8引擎完成了该框架，该框架，称为nodejs

**V8，将JS的执行推向了一个新的台阶**

4. ES标准的发展

ES1，1997年
ES2，1998年
ES3，1999年
ES5，2009年，习惯上，不再区分 javascript （JS） 和 ECMAScript （ES）
ES6，2015年，ECMA宣布，从ES6开始，使用年号作为版本号，ES6的真正称呼为：ES2015
ES7，2016年，ES2016

**非常重要：ES制定语言标准，不涉及语言的运行环境。正是因为ES避免了运行环境，就让ES有机会在各种环境中执行。ES称为了通用编程语言**

**本课程学习的是，ES的通用语法、浏览器环境为其注入的新功能**

**通常，把ES运行的环境称之为，宿主环境**


## JS语言特性

- 解释型语言

编译型语言：C语言、C++、java语言、C#语言

编译型语言会经过一个翻译的过程，负责翻译的叫做编译器，翻译的结果，叫做编译结果。

优点：执行速度快
缺点：某个编译结果，难以适用于各种环境（跨平台障碍）；部署繁琐；

解释型语言：js、php

解释型语言没有编译结果

优点：跨平台；部署简单；
缺点：执行速度稍慢

- 弱类型语言

弱类型：存放的数据类型可变。优点：灵活、易上手； 缺点：不严谨

强类型：存放的数据类型不可变。优点：严谨；缺点：不灵活、不易上手

> 通常，将弱类型的解释型语言，称为脚本语言

- 单线程

同步现象：上一件事情没有做完，下一件事情必须等待。

- 异步

提高单线程的执行效率。



# 开发环境的准备 {ignore=true}

[toc]

## 浏览器

chrome

## 代码编辑器

ATom
WebStorem
sublime
windows记事本
VSCode  Visual Studio Code

安装常用的插件：

1. 语言包：Chinese (Simplified) Language Pack for Visual Studio Code
2. Beautify：美化代码的作用
3. vscode-icons：美化图标
4. Live Server：自动搭建本地服务器，启动网页
5. Markdown Preview Enhanced：markdown的增强插件
6. Markdown All in One: 在markdown适用快捷键

## 准备工程



# 第一个JS程序

## 浏览器环境中，代码书写位置

1. 直接书写到页面中的script元素的内部
2. 书写到外部的js文件，在页面中引用 [推荐]

代码分离：内容、样式、功能，三者分离，更加容易维护和阅读

- 页面中，可以存在多个script元素，执行顺序从上到下
- 如果一个script元素引用了外部文件，内部不能书写任何代码
- script元素有一个可选的属性，type，该属性用于指定代码的类型，该属性值是MIME格式

## 认识基本语法

- 语法部分必须都是英文符号
- js代码由多条语句构成，每个语句用英文分号结束（并非强制要求）
- js代码从上到下同步执行
- js语言大小写敏感

## 认识输出语句

所有的输出语句都不是ES标准。

- document.write，该语句用于将数据输出到页面
- alert，该语句用于将数据用弹窗的形式显示到页面
- console.log，该语句用于将数据显示到控制台

## 认识输入语句

所有的输入语句都不是ES标准

## 认识注释

注释：提供给代码阅读者使用，不会参与执行

1. 单行注释  //
2. 多行注释  /*   */

在VSCode中，使用快捷键 ctrl + /，可以快速添加和取消单行注释
使用快捷键 alt + shift + a，可以快速添加和取消多行注释


## 作业

1. 在网页中书写多个script元素，在元素内部书写多种输出语句，然后运行页面查看效果。

2. 将代码提取到一个独立的js文件中，然后在页面中使用。



# 数据和数据类型

数据：有用的信息

数据类型：数据的分类

本节课学习的是：不同类型的数据的字面量表示法

## JS中的数据类型

学习JS中，不同数据类型的数据的书写方式

### 原始类型(基本类型)

原始类型指不可再细分的类型

1. 数字类型 number

直接书写即可

> 了解：
> 数字类型可以加上前缀，来表示不同的进制
> 0：表示8进制
> 0x：表示16进制
> 0b: 表示2进制

2. 字符串类型 string

字符串：一长串文本（0个或多个）

- 单引号 '
- 双引号 "
- 飘，`，叫做模板字符串

在字符串中，如何表示一个特殊字符，可以使用转义符（\）

3. 布尔类型 boolean

布尔类型用于表达真或假两种状态

- true，表示真
- false，表示假

4. undefined类型

表示未定义，不存在。

只有一种数据书写方式：undefined

5. null类型

表示空，不存在。

只有一种数据书写方式：null


> 区分某些长数字和字符串: 如果按照数字的方式阅读，则使用数字类型；否则使用字符串类型

### 引用类型

引用类型有两种：

- 对象 object （事物，东西，玩意儿）

可以认为，对象，是由多个基本类型组合而成。

书写对象的格式见 test6.html

**属性**：对象的成员

- 函数（后续章节专门讲解）


## 得到数据的类型

在数据前加上 typeof

> js的bug（特征）： typeof null，得到的是object

## 字面量

直接书写的具体的数据，叫做**字面量**

## 作业

将自己作为一个对象，书写合适的对象属性，输出该对象。




# 变量

## 什么是变量

变量是一块内存空间，用于保存数据

> 计算机：CPU、内存、硬盘、输入输出设备
> 内存：存取速度快，数据易丢失
> 硬盘：存取速度慢，数据永久保存
> 计算机程序的运行，仅与内存打交道

## 如何使用变量

1. 声明（定义）变量

```js
var 变量名;
```

**变量声明后，它的值为undefined**

2. 给变量赋值

向变量的内存空间中存放数据


- 变量的值是可变的

变量可以被重新赋值，新的值会覆盖原来的值

- 变量的名称

在开发中，凡是需要自行命名的位置，叫做标识符

标识符的规范：

1） [必]只能以英文字母、下划线、$开头
2)  [必]其他位置可以出现数字、英文字母、下划线、$
3)  [必]不可以与关键字、保留词重复
4)  [选]标识符应该做到望文知义
5)  [选]如果有多个单词，使用驼峰命名法，单词首字母大写

> 大驼峰：每个单词首字母大写
> 小驼峰：除第一个单词外，首字母大写
> 目前，使用的标识符都是小驼峰命名法。

> 宽度：width，高度：height，区域：area （quyu）

- 声明和赋值合并

变量的声明和赋值可以一条语句书写。

这是语法糖。

语法糖仅仅是为了方便代码书写或记忆，并不会有实质性的改变。

- 多个变量可以合并声明并赋值

语法糖

- **任何可以书写数据的地方，都可以书写变量**

- 若使用一个未声明的变量，会导致错误

例外：使用typeof得到类型时，可以是未声明的变量，得到的结果是undefined

- **JS中存在变量提升**

所有变量的声明，会自动的提到代码的最顶部

但是，这种提升，不会超越脚本块。

- JS中允许定义多个同名变量

同名变量，提升后会变成一个。


## 作业

定义三个变量，分别保存用户姓名、用户年龄、用户是否是vip，然后输出它们。



# 变量和对象

原始类型：number、string、boolean、null、undefined

引用类型：object、function 函数

## 在变量中存放对象

1. 通过变量，读取对象中的某个属性

```js
变量名.属性名
```

**当读取的属性不存在时，会得到undefined**

**当读取属性的对象不存在（undefined 或 null）时，程序报错**

2. 通过变量，更改对象中的某个属性

**当赋值的属性不存在时，会添加属性**

3. 删除属性

```js
delete 变量名.属性名;
```

4. 属性表达式

给属性赋值，或读取属性时，可以使用下面的格式操作

```js
对象变量["属性名"]
```

- 某些属性名中包含特殊字符

实际上，JS对属性名的命名要求并不严格，属性可以是任何形式的名字

**属性的名字只能是字符串，如果你书写的是数字，会自动转换为字符串**


## 全局对象

JS大部分的宿主环境，都会提供一个特殊的对象，该对象可以直接在JS代码中访问，该对象叫做全局对象

在浏览器环境中，全局对象为window，表示整个窗口

全局对象中的所有属性，可以直接使用，而不需要写上全局对象名。

**开发者定义的所有变量，实际上，会成为window对象的属性。**

**如果变量没有被赋值，则该变量不会覆盖window对象上的同名属性。**




# 引用类型

原始类型 引用类型（对象、函数）

**原始类型的变量，存放的具体的值**

**引用类型的变量，存放的是内存地址**

**凡是出现对象字面量的位置，都一定在内存出现一个新的对象**

> 扩展知识：JS中的垃圾回收
> 垃圾回收器，会定期的发现内存中无法访问到的对象，该对象称之为垃圾，垃圾回收器会在合适的时间将其占用的内存释放。




# 比较运算符

大小比较： >  <   >=   <=
相等比较： ==   != === !==

**比较运算符的返回类型：boolean**
**算数运算符的优先级高于比较运算符**

## 大小比较

两个字符串比较大小，比较的是字符串的字符编码。
> 字符串比较大小时，是一位一位进行比较
```js
console.log("AB" > "A");
第一步：先比较第一位，即："A"与"A"比较，然后"B"在进行比较
```

**细节**

1. 两个字符串比较大小，比较的是字符串的字符编码。
2. 如果一个不是字符串，并不且两个都是原始类型，将他们都转换为数字进行比较
   ```js
    console.log("1" >= 1);
    console.log("2" > true);
    ```
- NaN与任何数字进行比较，得到的结果都是**false**
    ```js
    console.log(NaN > 0);
    ```
- Infinity比任何数字都大
- -Infinity比任何数字都小

3. 如果其中一个是对象，讲对象转换为原始类型，然后按照规则1或者规则2进行比较

> 目前，对象转换为原始类型后，是字符串 "[Object Object]"
```js
console.log(1 > {});//false
1.{}转换为字符串为:"[Object Object]"
2.字符串"[Object Object]"转换为数字为NaN
3.NaN与任何数字进行比较,结果都是false
console.log(null > -1);//true
console.log(undefined > -1);//false
undefined转换为数字为NaN
```

## 相等比较

### == 和 !=  （相等比较和不相等比价）

==: 比较两个数据是否相等，相等返回true，不相等返回false
!=: 比较两个数据是否不相等

```js
console.log(1 == 1);//true
console.log(1 != 1);//false
console.log("abc" == "abc");//true
```

**细节**

1. 两端的数据类型相同：直接比较两个数据本身是否相同（两个对象比较的地址）

2. 两端的类型不同
        
1). null 和 undefined，他们直接相等，和其他原始类型比较，则不相等
```js
console.log(null == undefined);//true
console.log(null != undefined);//false
console.log(null == 0);//false
console.log(null >= 0); //true
console.log(undefined == 0); //false
```

2). 其他原始类型比较时，先转换为数字，再进行比较
```js
console.log("1" == 1);//true
```

3). NaN与任何数字比较，包括自身都是**false**

4). Infinity 和 -Infinity，**自身和自身相等**

5). 对象比较时，要先转换为原始类型，再进行比较

**由于相等和不相等比较，对于不同类型的数据比较违反直觉，因此，通常我们不使用这种比较方式，而是使用功能架接近直觉的严格相等和严格不相等进行比较**

### ===  和 !==  （严格相等和严格不相等）

===： 两端的数据和类型必须相同，才为true
!==:  两端的数据或类型不相同
```js
console.log(1 === true);//false
```

1. 两端类型相同，规则和相等比较一致。
2. 两端类型不同，为false

数字规则：
1). NaN与任何数字比较，包括自身都是**false**
2). Infinity 和 -Infinity，**自身和自身相等**


# 逻辑运算符

逻辑运算符：也叫作**布尔运算符**

## 与（并且）

符号： &&

书写方式： 表达式1 && 表达式2  两个表达式都要满足

1. 将表达式1进行boolean判定

以下数据均判定为false：

1) null
2) undefined
3) false
4) NaN
5) " "
6) 0

其他数据全部为真

2. 如果表达式1的判定结果为**假**，则直接返回表达式1，而不执行表达式2；反之，则返回表达式2的结果。（短路规则）

```js
console.log(5 > 3 && 3 > 2);//true
console.log(5 > 3 && 100);//100
console.log(0 && 2);//0

經典題1：
var x = 1;
console.log(x > 2 && x++ > 0);//false
console.log(x);//1

經典題2：
console.log(1 && 2 && 3 && 4 && 0);//0

```  

## 或

符号： ||

写法： 表达式1 || 表达式2

1. 将表达式1 进行 boolean 判定

2. 如果表达式1为**真**，直接返回表达式1，不运行表达式2； 否则，返回表达式2

## 非

符号： ！

写法： !数据

一元运算符

将数据的boolean判定结果直接取反，非运算符一定返回boolean类型


# 三目运算符

书写方式： 表达式1 ？ 表达式2 ：表达式3

1. 对表达式1进行boolean判定
2. 如果判定结果为真，返回表达式2；否则，返回表达式3

# 补充知识

## 模板字符串

```js
` `

var user = {
    age : 18,
    sex : "男",
    name : "不知道"
}
console.log("我叫" + user.name + ", 我今年" + user.age + ",我是一个" + user.sex);
console.log(`我叫${user.name},我今年${user.age}岁了，我是一个${user.sex}`);

```
## 类型转换不会影响原本的数据

```js

var x = "1";
var y = x + 2;
console.log(x, typeof x);//1, string
//仅仅只是在运算过程中将字符串转为数字类型，但是实质类型仍然为string
// typeof：表示查看一个变量的类型，是一个字符串

```
## 复合的赋值运算符

+=  -=  /=  *=  %=  **=

```js

var x = 1;
    x = x++;//x = x + 1
    x *= x++ + 2; // x = x * (x++ + 2);

```

## void 运算符

一元运算符

写法：

1. 普通写法： ``` void 表达式  ```
2. 函数写法： ``` void(表达式)  ```

运行表达式，然后返回undefined

## typeof 运算符

一元运算符

写法：

1. 普通写法： ``` typeof 表达式  ```
2. 函数写法： ``` typeof(表达式)  ```

typeof运算，返回表达式的类型，是一个字符串。

## 逗号运算符

写法：表达式1, 表达式2

依次运行两个表达式，返回表达式2

逗号运算符的优先级比赋值更低

```js

var x = 1;
        x = (x++ * 2, x++ * 2, x++ * 2);
        console.log(x);

```

# 数字的存储

**在对精度要求很高的系统中，或要对小数的运算结果进行比较时，需要特别谨慎**

## 问题

1. JS中的小数运算是精确的吗？

不一定

2. JS中的整数运算是精确的吗？

不一定

3. JS中表示的整数是连续的吗？

不是，当JS的数字很大的时候，不再连续。

4. JS中表示的最大数字是多少？

最大连续整数：9007199254740991

5. JS中能表示的数字的有效位数是多少？

16 ~ 17



## 二进制

现实世界中：十进制，10个数字，逢十进一

计算机世界中：二进制，2个数字，逢二进一

二进制 -> 十进制

1101 -> $1*2^3 + 1*2^2 + 0*2^1 + 1*2^0 = 13$

11.01 -> $1*2^1 + 1*2^0 + 0*2^{-1} + 1*2^{-2} = 3.25$

十进制 -> 二进制

13 -> 1101

```
13 / 2  商 6    余  1
6  / 2  商 3    余  0
3  / 2  商 1    余  1
1  / 2  商 0    余  1
余数从下往上看
```

3.25 -> 11.01

整数部分一样

小数部分

```
0.25 * 2    0.5     整数部分：0
0.5  * 2    1.0     整数部分：1
整数部分从上往下看
```

## 为什么JS的小数运算不精确

十进制的小数，转换为二进制后，可能是无限小数，但是计算机对数字的存储能力有限，因此会丢失一些数据。

十进制数 0.3 -> 0.010011001100110011001.....

```
0.3*2   0.6     0
0.6*2   1.2     1
0.2*2   0.4     0
0.4*2   0.8     0
0.8*2   1.6     1
0.6*2   1.2     1
0.2*2   0.4     0
......
整数部分从上往下看
```

## JS如何存储数字

整数法、浮点法

JS中，存储的所有数字，都按照浮点法存放。

浮点法存放的数字，叫做浮点数（float），浮点数分为单精度和双精度。

JS中，使用双精度存放浮点数，IEEE 754。

**存放方式**

JS在计算机中，给每个数字开辟一块内存空间，尺寸固定为64位

> 在计算机中，位（bit）是最小的存储单位，简称为bit
> 1 byte = 8 bit
> 1 KB = 1024 byte
> 1 MB = 1024 KB
> 1 GB = 1024 MB

```
[第1段][第2段][第3段]

第1段：1位，表示符号位，如果为1，是负数，如果为0，是正数
第2段：11位，表示指数位，这里的指数是2为底的指数，而不是10
第3段：52位，表示有效数字
```

举例

```
0     1000 0000 011    1111 0000 0000 0000....
```
相当于： $1.1111 * 2 ^ {1027 - 1023} $

**特殊情况**

1. 指数为0，尾数为0，表示数字 0
2. 符号为0，指数为2047，尾数为0，表示正无穷

```
Infinity: 0 11111111111 00000000000...
```

3. 符号为1，指数为2047，尾数为0，表示负无穷

```
-Infinity: 1 11111111111 00000000000...
```

4. 指数为2047，尾数不为0，表示NaN

```
NaN: 1 11111111111 01001010000...
```

**一个正常的数字，指数部分最多是2046**

## 能表示的最大数字

```
0 11111111110 1111111111.........
```

相当于： $1.1111111111... * 2 ^ 1023 $

## 能表示的最大的安全整数

安全数字：从1开始到该数字，均是连续的整数，并且该数字的下一个整数是存在的。

```
0 xxxxx 1111111111....
```

相当于： $2^53 - 1$

下一位： $2^53$   ```0  xxxxx  0000000000000```














# 流程图

一套的标准的图形，用于描述程序的逻辑

通常流程图分析程序的流程

![](assets/2019-06-12-10-49-09.png)

> markdown中粘贴图片，ctrl + alt + v

## 在 markdown 中画流程图

```mermaid
graph TD
start((开始))-->if{判断}
if--true-->A[adsfasf]
if--false-->ed((结束))
A-->ed
```

## 例子

邓哥的思维：

```mermaid
graph TD
st((开始)) --> buyPeach[买两个桃子]
buyPeach-->if{是否碰到卖西瓜的}
if--true-->buyXigua[买一个西瓜]
if--false-->ed((结束))
buyXigua-->ed
```

成哥的思维：

```mermaid
graph TD
st((开始)) --> if{是否碰到卖西瓜的}
if--true-->买一个桃子
if--false-->买两个桃子
买一个桃子-->ed((结束))
买两个桃子-->ed
```

# if判断

```js
if(条件1){
    // 代码块
}
else if(条件2){
    // 代码块
}
else if(条件3){
    // 代码块
}
//....
else{
    // 以上条件都不满足执行的代码块
}
```

1. 如果某个条件满足，则直接忽略后面的所有条件
2. else if 可以有多个（包含0个）
   ```js
    if (条件) {}
    ```
3. else可以有1个或0个
   ```js
    if (条件) {
    //代码块
   }else if (条件2) {
   //代码块
   }
    ```
4. else可以换行，可以不换行
5. 如果代码块只有一条语句，可以省略花括号（不推荐）
6. if只能出现一次


## 补充

1. 用户输入: prompt("提示文本")

该表达式返回结果：

- null：表示用户点击了取消
- 用户输入的字符串：表示用户点击了确定，得到用户输入的结果

返回类型：null 或 字符串

```js
    var result = prompt("请输入你的年龄");
    if (result === null) {
        alert("你点击了取消")
    } else {
        result = +result;//将字符串转为数字
        if (isNaN(result)) {
            console.log("不是正常的数字")
        }else {
            console.log(result, typeof result);
        }
    }
```

2. 将字符串转换成数字：**+字符串**

3. 得到一个随机数

Math.random() 该表达式返回一个0~1之间的随机数字（无法取到1）


# switch 开关

switch的语法始终可以使用if结构替代。

```js
switch(表达式){
    case 数据1:
        代码块
    case 数据2:
        代码块
    //...
    default:
        代码块
}
```

1. 计算表达式的返回值，依次和case后面的数据进行严格相等的比较，如果某个相等，停止比较，然后运行其内部的代码块，再然后，依次运行之后的所有代码块。
2. 在case分支内部，使用break语句，可以立即停止switch结构。
3. default表示前面的所有case都不匹配时运行。可以省略

# 循环

重复的运行一段代码

JS支持3种循环结构：while循环、do-while循环、for循环

## while循环

```js
while(条件){
    代码块（循环体）
}
```

```mermaid
graph TD

st((开始))-->条件{条件}
条件--true-->代码块
代码块-->条件
条件--false-->ed((结束))
```

死循环：条件永远满足，永远无法退出循环。

## do-while循环

```js
do{
    循环体
} while(条件);
```

```mermaid
graph TD

st((开始))-->代码块
代码块-->条件{条件}
条件--true-->代码块
条件--false-->ed((结束))
```


## for循环

```js
for(初始化表达式; 条件; 条件改变表达式){
    循环体
}
```

```mermaid
graph TD

st((开始))-->初始化表达式
初始化表达式-->条件{条件}
条件--true-->循环体
循环体-->条件改变表达式
条件改变表达式-->条件
条件--false-->ed((结束))
```


## 循环中的关键字

循环控制语句

- break; 跳出循环
- continue; 停止当前循环体，进入下一次循环。


# 循环应用

## 累计

举例：将1-100的所有数字相加之和

思路：准备一个变量，初始值为0，然后1-100循环，每次循环，将数字累加到变量中。

## 查找

举例：135~145之间是否存在能整除26的数字

思路：准备一个变量，记录false，表示没有找到，然后135-145进行循环，如果发现满足条件的数字，重新记录变量为true，表示找到了，然后退出循环。

## 嵌套的循环

分开分析两层循环




# 数组

数组用于存放多个数据

## 创建一个数组

1. new Array(长度)

长度，数组里面的数据总数，长度一定是一个非负整数

new Array(数据, 数据, 数据....)

创建一个数组，并初始化其每一项的值

数组项：数组其中的一项数据

2. [数据,数据,数据,....]

创建一个数据，并初始化其每一项的值

## 认识数组的本质

![img.png](img.png)

数组的本质是一个对象

- length属性：数组的长度，会自动变化，值为最大下标+1
- 数字字符串属性：叫做下标，也叫做索引，相当于数组中每个数据的编号，下标从0开始排列


连续下标的取值范围：0 ~ length -1，如果给length直接赋值，会导致数组可能被截断

实际开发中，不要给length赋值。

## 下标

通常情况下，下标是连续的。

下标不连续的数组，叫做稀松数组。

## 数组的常见操作

### 添加数组项

- 数组[长度] = 数据：向数组末尾添加一个数据
- 数组.push(数据): 向数组末尾添加一个数据
- 数组.unshift(数据)：向数组起始位置添加一个数据，会导致数组每一项的下标向后移动
- 数组.splice(下标, 0, 添加的数据): 从指定下标位置开始，删除0个，然后在该位置插入添加的数据，如果下标超过范围，则按照范围的边界进行处理。

push、unshift、splice可以添加多个数据

### 删除数据

- delete 数组[下标]: 这种做法不会导致数组其他的属性发生变化，因此，该做法会导致产生稀松数组，所以不推荐使用该做法。
- 数组.pop(): 删除数组的最后一项，该表达式返回最后一项的数据
- 数组.shift()：删除数组第一项，该表达式返回第一项的数据
- 数组.splice(下标, 删除的数量, 添加的数据): 从指定下标位置开始，删除指定数量，然后在该位置插入添加的数据，如果下标超过范围，则按照范围的边界进行处理。返回一个新数组，该数组记录被删除的数据。

### 其他操作

- 数组.slice(起始位置下标, 结束位置下标)：将起始位置到结束位置之间的数据拿出来，得到一个新的数组，该函数不会改变原数组；注意：结束下标取不到

下标可以写负数，如果是负数，则从数组的末尾开始计算。

如果不写结束下标，则直接取到末尾。

- 数组清空

数组.splice(0, 数组.length);

数组.length = 0;

- 查找数组中某一项的下标

数组.indexOf(数据)

从数组中依次查找对应的数据，查找时使用严格相等进行比较。找到第一个匹配的下标，返回。如果没有找到，则得到-1；

数组.lastIndexOf(数据)

功能和indexOf类似，只是查找的是最后一个匹配的下标

- 数组.fill

数组.fill(数据)：将数组的所有项，填充为指定的数据

数组.fill(数组, 开始下标): 将数组从开始下标起，到数组的末尾，填充为指定的数据

数组.fill(数组, 开始下标，结束下标): 将数组从开始下标起，到数组的结束下标（取不到），填充为指定的数据



## 语法补充

### in关键字

判断某个属性在对象中是否存在

属性名 in 对象

### for-in  foreach 循环

```js
for(var prop in 对象){
    //循环体
}
```

取出对象的所有属性名，每次循环将其中一个属性名赋值给变量prop，运行循环体。
